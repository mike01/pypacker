"""
Checksum logic vor various protocols.
"""
import array
import socket
import struct
import logging

logger = logging.getLogger("pypacker")

# avoid references for performance reasons
unpack = struct.unpack
unpack_word_be = struct.Struct(">H").unpack
array_call = array.array
ntohs = socket.ntohs

# TCP (RFC 793) and UDP (RFC 768) checksum


def in_cksum_add(s, buf):
	"""Add checksum value to the given value s."""
	n = len(buf)
	# logger.debug("buflen for checksum: %d" % n)
	cnt = int(n / 2) * 2
	# logger.debug("slicing at: %d, %s" % (cnt, type(cnt)))
	a = array_call("H", buf[:cnt])
	# logger.debug("2-byte values: %s" % a)
	# logger.debug(buf[-1].to_bytes(1, byteorder='big'))

	if cnt != n:
		#a.append(unpack_word_be( buf[-1].to_bytes(1, byteorder="big") + b"\x00" )[0])
		a.append(unpack_word_be(buf[-1:] + b"\x00")[0])
	return s + sum(a)


def in_cksum_done(s):
	"""Complete checksum building."""
	# add carry to sum itself
	s = (s >> 16) + (s & 0xFFFF)
	s += (s >> 16)
	# return complement of sums
	return ntohs(~s & 0xFFFF)


def in_cksum(buf):
	"""Return computed Internet Protocol checksum."""
	return in_cksum_done(in_cksum_add(0, buf))


# CRC-32C Checksum
# http://tools.ietf.org/html/rfc3309

crc32c_table = (
	0x00000000, 0xF26B8303, 0xE13B70F7, 0x1350F3F4, 0xC79A971F,
	0x35F1141C, 0x26A1E7E8, 0xD4CA64EB, 0x8AD958CF, 0x78B2DBCC,
	0x6BE22838, 0x9989AB3B, 0x4D43CFD0, 0xBF284CD3, 0xAC78BF27,
	0x5E133C24, 0x105EC76F, 0xE235446C, 0xF165B798, 0x030E349B,
	0xD7C45070, 0x25AFD373, 0x36FF2087, 0xC494A384, 0x9A879FA0,
	0x68EC1CA3, 0x7BBCEF57, 0x89D76C54, 0x5D1D08BF, 0xAF768BBC,
	0xBC267848, 0x4E4DFB4B, 0x20BD8EDE, 0xD2D60DDD, 0xC186FE29,
	0x33ED7D2A, 0xE72719C1, 0x154C9AC2, 0x061C6936, 0xF477EA35,
	0xAA64D611, 0x580F5512, 0x4B5FA6E6, 0xB93425E5, 0x6DFE410E,
	0x9F95C20D, 0x8CC531F9, 0x7EAEB2FA, 0x30E349B1, 0xC288CAB2,
	0xD1D83946, 0x23B3BA45, 0xF779DEAE, 0x05125DAD, 0x1642AE59,
	0xE4292D5A, 0xBA3A117E, 0x4851927D, 0x5B016189, 0xA96AE28A,
	0x7DA08661, 0x8FCB0562, 0x9C9BF696, 0x6EF07595, 0x417B1DBC,
	0xB3109EBF, 0xA0406D4B, 0x522BEE48, 0x86E18AA3, 0x748A09A0,
	0x67DAFA54, 0x95B17957, 0xCBA24573, 0x39C9C670, 0x2A993584,
	0xD8F2B687, 0x0C38D26C, 0xFE53516F, 0xED03A29B, 0x1F682198,
	0x5125DAD3, 0xA34E59D0, 0xB01EAA24, 0x42752927, 0x96BF4DCC,
	0x64D4CECF, 0x77843D3B, 0x85EFBE38, 0xDBFC821C, 0x2997011F,
	0x3AC7F2EB, 0xC8AC71E8, 0x1C661503, 0xEE0D9600, 0xFD5D65F4,
	0x0F36E6F7, 0x61C69362, 0x93AD1061, 0x80FDE395, 0x72966096,
	0xA65C047D, 0x5437877E, 0x4767748A, 0xB50CF789, 0xEB1FCBAD,
	0x197448AE, 0x0A24BB5A, 0xF84F3859, 0x2C855CB2, 0xDEEEDFB1,
	0xCDBE2C45, 0x3FD5AF46, 0x7198540D, 0x83F3D70E, 0x90A324FA,
	0x62C8A7F9, 0xB602C312, 0x44694011, 0x5739B3E5, 0xA55230E6,
	0xFB410CC2, 0x092A8FC1, 0x1A7A7C35, 0xE811FF36, 0x3CDB9BDD,
	0xCEB018DE, 0xDDE0EB2A, 0x2F8B6829, 0x82F63B78, 0x709DB87B,
	0x63CD4B8F, 0x91A6C88C, 0x456CAC67, 0xB7072F64, 0xA457DC90,
	0x563C5F93, 0x082F63B7, 0xFA44E0B4, 0xE9141340, 0x1B7F9043,
	0xCFB5F4A8, 0x3DDE77AB, 0x2E8E845F, 0xDCE5075C, 0x92A8FC17,
	0x60C37F14, 0x73938CE0, 0x81F80FE3, 0x55326B08, 0xA759E80B,
	0xB4091BFF, 0x466298FC, 0x1871A4D8, 0xEA1A27DB, 0xF94AD42F,
	0x0B21572C, 0xDFEB33C7, 0x2D80B0C4, 0x3ED04330, 0xCCBBC033,
	0xA24BB5A6, 0x502036A5, 0x4370C551, 0xB11B4652, 0x65D122B9,
	0x97BAA1BA, 0x84EA524E, 0x7681D14D, 0x2892ED69, 0xDAF96E6A,
	0xC9A99D9E, 0x3BC21E9D, 0xEF087A76, 0x1D63F975, 0x0E330A81,
	0xFC588982, 0xB21572C9, 0x407EF1CA, 0x532E023E, 0xA145813D,
	0x758FE5D6, 0x87E466D5, 0x94B49521, 0x66DF1622, 0x38CC2A06,
	0xCAA7A905, 0xD9F75AF1, 0x2B9CD9F2, 0xFF56BD19, 0x0D3D3E1A,
	0x1E6DCDEE, 0xEC064EED, 0xC38D26C4, 0x31E6A5C7, 0x22B65633,
	0xD0DDD530, 0x0417B1DB, 0xF67C32D8, 0xE52CC12C, 0x1747422F,
	0x49547E0B, 0xBB3FFD08, 0xA86F0EFC, 0x5A048DFF, 0x8ECEE914,
	0x7CA56A17, 0x6FF599E3, 0x9D9E1AE0, 0xD3D3E1AB, 0x21B862A8,
	0x32E8915C, 0xC083125F, 0x144976B4, 0xE622F5B7, 0xF5720643,
	0x07198540, 0x590AB964, 0xAB613A67, 0xB831C993, 0x4A5A4A90,
	0x9E902E7B, 0x6CFBAD78, 0x7FAB5E8C, 0x8DC0DD8F, 0xE330A81A,
	0x115B2B19, 0x020BD8ED, 0xF0605BEE, 0x24AA3F05, 0xD6C1BC06,
	0xC5914FF2, 0x37FACCF1, 0x69E9F0D5, 0x9B8273D6, 0x88D28022,
	0x7AB90321, 0xAE7367CA, 0x5C18E4C9, 0x4F48173D, 0xBD23943E,
	0xF36E6F75, 0x0105EC76, 0x12551F82, 0xE03E9C81, 0x34F4F86A,
	0xC69F7B69, 0xD5CF889D, 0x27A40B9E, 0x79B737BA, 0x8BDCB4B9,
	0x988C474D, 0x6AE7C44E, 0xBE2DA0A5, 0x4C4623A6, 0x5F16D052,
	0xAD7D5351
)


def crc32_add(crc, buf):
	# buf = array.array("B", buf)
	i = 0
	while i < len(buf):
		# crc = (crc >> 8) ^ crc32c_table[(crc ^ b) & 0xFF]
		crc = (crc >> 8) ^ crc32c_table[(crc ^ buf[i]) & 0xFF]
		i += 1
	return crc


def crc32_done(crc):
	tmp = ~crc & 0xFFFFFFFF
	b0 = tmp & 0xFF
	b1 = (tmp >> 8) & 0xFF
	b2 = (tmp >> 16) & 0xFF
	b3 = (tmp >> 24) & 0xFF
	crc = (b0 << 24) | (b1 << 16) | (b2 << 8) | b3
	return crc


def crc32_cksum(buf):
	"""Return computed CRC-32c checksum."""
	return crc32_done(crc32_add(0xFFFFFFFF, buf))


def fletcher32(data_to_checksum, amount_words):
	# 1 word = 2 Bytes
	sum1 = 0xFFFF
	sum2 = 0xFFFF
	datapos = 0

	while amount_words > 0:
		tlen = 359 if amount_words > 359 else amount_words
		amount_words -= tlen

		while tlen > 0:
			# sum1 += unpack_word_be(data_to_checksum[datapos:datapos+2])[0]
			# print("%d" % sum1)
			sum1 += unpack_word_be(data_to_checksum[datapos: datapos + 2])[0]
			datapos += 2
			sum2 += sum1
			# print("%d" % sum1)
			# print("%d" % sum2)
			# print("--")
			tlen -= 1
		sum1 = (sum1 & 0xFFFF) + (sum1 >> 16)
		sum2 = (sum2 & 0xFFFF) + (sum2 >> 16)
	# Second reduction step to reduce sums to 16 bits
	sum1 = (sum1 & 0xFFFF) + (sum1 >> 16)
	sum2 = (sum2 & 0xFFFF) + (sum2 >> 16)
	return (sum2 << 16) | sum1


crc_table_btle = (
	0x000000, 0x01b4c0, 0x036980, 0x02dd40, 0x06d300, 0x0767c0, 0x05ba80, 0x040e40,
	0x0da600, 0x0c12c0, 0x0ecf80, 0x0f7b40, 0x0b7500, 0x0ac1c0, 0x081c80, 0x09a840,
	0x1b4c00, 0x1af8c0, 0x182580, 0x199140, 0x1d9f00, 0x1c2bc0, 0x1ef680, 0x1f4240,
	0x16ea00, 0x175ec0, 0x158380, 0x143740, 0x103900, 0x118dc0, 0x135080, 0x12e440,
	0x369800, 0x372cc0, 0x35f180, 0x344540, 0x304b00, 0x31ffc0, 0x332280, 0x329640,
	0x3b3e00, 0x3a8ac0, 0x385780, 0x39e340, 0x3ded00, 0x3c59c0, 0x3e8480, 0x3f3040,
	0x2dd400, 0x2c60c0, 0x2ebd80, 0x2f0940, 0x2b0700, 0x2ab3c0, 0x286e80, 0x29da40,
	0x207200, 0x21c6c0, 0x231b80, 0x22af40, 0x26a100, 0x2715c0, 0x25c880, 0x247c40,
	0x6d3000, 0x6c84c0, 0x6e5980, 0x6fed40, 0x6be300, 0x6a57c0, 0x688a80, 0x693e40,
	0x609600, 0x6122c0, 0x63ff80, 0x624b40, 0x664500, 0x67f1c0, 0x652c80, 0x649840,
	0x767c00, 0x77c8c0, 0x751580, 0x74a140, 0x70af00, 0x711bc0, 0x73c680, 0x727240,
	0x7bda00, 0x7a6ec0, 0x78b380, 0x790740, 0x7d0900, 0x7cbdc0, 0x7e6080, 0x7fd440,
	0x5ba800, 0x5a1cc0, 0x58c180, 0x597540, 0x5d7b00, 0x5ccfc0, 0x5e1280, 0x5fa640,
	0x560e00, 0x57bac0, 0x556780, 0x54d340, 0x50dd00, 0x5169c0, 0x53b480, 0x520040,
	0x40e400, 0x4150c0, 0x438d80, 0x423940, 0x463700, 0x4783c0, 0x455e80, 0x44ea40,
	0x4d4200, 0x4cf6c0, 0x4e2b80, 0x4f9f40, 0x4b9100, 0x4a25c0, 0x48f880, 0x494c40,
	0xda6000, 0xdbd4c0, 0xd90980, 0xd8bd40, 0xdcb300, 0xdd07c0, 0xdfda80, 0xde6e40,
	0xd7c600, 0xd672c0, 0xd4af80, 0xd51b40, 0xd11500, 0xd0a1c0, 0xd27c80, 0xd3c840,
	0xc12c00, 0xc098c0, 0xc24580, 0xc3f140, 0xc7ff00, 0xc64bc0, 0xc49680, 0xc52240,
	0xcc8a00, 0xcd3ec0, 0xcfe380, 0xce5740, 0xca5900, 0xcbedc0, 0xc93080, 0xc88440,
	0xecf800, 0xed4cc0, 0xef9180, 0xee2540, 0xea2b00, 0xeb9fc0, 0xe94280, 0xe8f640,
	0xe15e00, 0xe0eac0, 0xe23780, 0xe38340, 0xe78d00, 0xe639c0, 0xe4e480, 0xe55040,
	0xf7b400, 0xf600c0, 0xf4dd80, 0xf56940, 0xf16700, 0xf0d3c0, 0xf20e80, 0xf3ba40,
	0xfa1200, 0xfba6c0, 0xf97b80, 0xf8cf40, 0xfcc100, 0xfd75c0, 0xffa880, 0xfe1c40,
	0xb75000, 0xb6e4c0, 0xb43980, 0xb58d40, 0xb18300, 0xb037c0, 0xb2ea80, 0xb35e40,
	0xbaf600, 0xbb42c0, 0xb99f80, 0xb82b40, 0xbc2500, 0xbd91c0, 0xbf4c80, 0xbef840,
	0xac1c00, 0xada8c0, 0xaf7580, 0xaec140, 0xaacf00, 0xab7bc0, 0xa9a680, 0xa81240,
	0xa1ba00, 0xa00ec0, 0xa2d380, 0xa36740, 0xa76900, 0xa6ddc0, 0xa40080, 0xa5b440,
	0x81c800, 0x807cc0, 0x82a180, 0x831540, 0x871b00, 0x86afc0, 0x847280, 0x85c640,
	0x8c6e00, 0x8ddac0, 0x8f0780, 0x8eb340, 0x8abd00, 0x8b09c0, 0x89d480, 0x886040,
	0x9a8400, 0x9b30c0, 0x99ed80, 0x985940, 0x9c5700, 0x9de3c0, 0x9f3e80, 0x9e8a40,
	0x972200, 0x9696c0, 0x944b80, 0x95ff40, 0x91f100, 0x9045c0, 0x929880, 0x932c40
)

CRC_BTLE_INIT_ADV		= 0x555555
CRC_BTLE_INIT_ADV_REORDERED	= 0xAAAAAA


def crc_btle_check(buf, crc_init):
	"""
	AA + header + data + crc -> crc(header...data) -> compare crc_new <-> crc
	buf -- AA + header + data + crc
	return -- True if crc is correct, False otherwise
	"""
	crc_old = (buf[-1] & 0xFF) << 16 | (buf[-2] & 0xFF) << 8 | (buf[-3] & 0xFF)
	crc_new = crc_btle_update(buf[4:-3], crc_init)

	#logger.debug("crc old/new: %s == %s" % (crc_old, crc_new))
	return crc_old == crc_new


def crc_btle_update(data, crc_in):
	dlen = len(data)
	idx_data = 0

	for idx_data in range(dlen):
		idx_table = (crc_in ^ data[idx_data]) & 0xFF
		crc_in = (crc_table_btle[idx_table] ^ (crc_in >> 8)) & 0xFFFFFF
	return crc_in & 0xFFFFFF


def crc_btle_init_reorder(crc_init):
	# reverse bits: 0110001 -> 1000110
	return int("".join(reversed(bin(crc_init)[2:].rjust(3 * 8, "0"))), 2)
